name: 单平台镜像同步（直接推送版）

on:
  workflow_dispatch:  # 允许手动触发
  schedule:
    - cron: '*/15 * * * *'  # 每小时整点运行一次（UTC时间）

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 配置Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 登录镜像仓库
        run: |
          docker login docker.cnb.cool -u cnb -p ${{ secrets.cnb }}

      - name: 同步镜像（直接推送）
        run: |
          set -eo pipefail
          
          # 初始化Buildx
          docker buildx create --name img_sync --use
          docker buildx inspect --bootstrap

          # 读取镜像列表文件
          while IFS= read -r line; do
            # 跳过注释和空行
            [[ "$line" =~ ^#|^$ ]] && continue

            # 解析行内容（格式：源镜像 目标镜像 平台列表）
            src_image=$(echo "$line" | awk '{print $1}')
            dest_image=$(echo "$line" | awk '{print $2}')
            raw_platforms=$(echo "$line" | awk '{$1=$2=""; print $0}' | xargs)

            # 修正平台参数格式（示例输入：amd64,arm64 → 输出：linux/amd64,linux/arm64）
            platforms=$(echo "$raw_platforms" | sed 's/,/,linux\//g; s/^/linux\//')

            echo "🔍 正在处理: $src_image => $dest_image [平台: $platforms]"

            # 方法1：使用docker pull（简单直接）
            echo "🚀 方式1：通过docker pull同步..."
            docker pull "$src_image" --platform "$platforms"
            docker tag "$src_image" "$dest_image"
            docker push "$dest_image"

            # 方法2：使用buildx（推荐多平台场景）
            # echo "🚀 方式2：通过buildx同步..."
            # docker buildx build \
            #   --platform "$platforms" \
            #   --output=type=image,name=$dest_image,push=true \
            #   --cache-from=type=registry,ref=$src_image \
            #   - <<< "FROM $src_image"

            echo "🎉 同步成功: $dest_image"
            echo "----------------------------------------"
          done < "$GITHUB_WORKSPACE/images.txt"

          # 清理Buildx
          docker buildx rm img_sync || true
