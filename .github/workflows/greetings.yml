# name: Smart Multi-Arch Sync

# on:
#   workflow_dispatch:
#   schedule:
#     - cron: '* */3 * * *'


# jobs:
#   sync:
#     runs-on: ubuntu-latest
#     steps:

#     # å¢åŠ å¯ç”¨ç£ç›˜ç©ºé—´
#     - name: Maximize build space
#       uses: easimon/maximize-build-space@master
#       with:

#         root-reserve-mb: 2048
#         swap-size-mb: 128
#         remove-dotnet: 'true'
#         remove-haskell: 'true'
#         # å¦‚æœç©ºé—´è¿˜æ˜¯ä¸å¤Ÿç”¨ï¼Œå¯ä»¥æŠŠä»¥ä¸‹å¼€å¯ï¼Œæ¸…ç†å‡ºæ›´å¤šç©ºé—´
#         remove-android: 'true'
#         remove-codeql: 'true'
#         build-mount-path: '/var/lib/docker/'

#     - name: Restart docker
#       run: sudo service docker restart

#     - name: æ£€å‡ºä»£ç 
#       uses: actions/checkout@v4
      
#     # ç™»å½•åˆ° cnb
#     - name: ç™»å½•åˆ° cnb
#       run:
#           docker login docker.cnb.cool -u cnb -p ${{ secrets.cnb }}

#     - name: Setup Buildx
#       uses: docker/setup-buildx-action@v3
#       with:
#         platforms: linux/amd64,linux/arm64,linux/arm/v7

#     - name: Process Images
#       run: |
#         while IFS= read -r line; do
#           # Skip comments/empty lines
#           [[ "$line" =~ ^#|^$ ]] && continue

#           # Parse input
#           src_image=$(echo "$line" | awk '{print $1}')
#           dest_image=$(echo "$line" | awk '{print $2}')
#           platforms=$(echo "$line" | awk '{print $3}' | tr ',' ' ')

#           echo "ğŸ” Processing: $src_image => $dest_image (${platforms// /,})"

#           # Step 1: Pull multi-arch image
#           docker pull --platform=$(echo "$platforms" | tr ' ',',') $src_image

#           # Step 2: Push each arch with clear tagging
#           for arch in $platforms; do
#             arch_suffix=$(echo $arch | sed 's/\//-/g')  # arm/v7 => arm-v7
#             temp_tag="${dest_image}-${arch_suffix}-temp"
            
#             docker tag $src_image $temp_tag
#             docker push $temp_tag
#           done

#           # Step 3: Create unified manifest
#           manifest_cmd="docker manifest create ${dest_image}"
#           for arch in $platforms; do
#             arch_suffix=$(echo $arch | sed 's/\//-/g')
#             manifest_cmd+=" --amend ${dest_image}-${arch_suffix}-temp"
#           done
#           eval $manifest_cmd

#           # Step 4: Push final manifest
#           docker manifest push $dest_image

#           # Step 5: Cleanup temporary tags
#           for arch in $platforms; do
#             arch_suffix=$(echo $arch | sed 's/\//-/g')
#             docker rmi ${dest_image}-${arch_suffix}-temp || true
#           done

#           echo "âœ… Successfully pushed multi-arch: $dest_image"
#         done < images.txt
name: Smart Multi-Arch Sync with Update Check

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    # å¢åŠ å¯ç”¨ç£ç›˜ç©ºé—´
    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 2048
        swap-size-mb: 128
        remove-dotnet: 'true'
        remove-haskell: 'true'
        remove-android: 'true'
        remove-codeql: 'true'
        build-mount-path: '/var/lib/docker/'

    - name: Restart docker
      run: sudo service docker restart

    - name: æ£€å‡ºä»£ç 
      uses: actions/checkout@v4
      
    # ç™»å½•åˆ° cnb
    - name: ç™»å½•åˆ° cnb
      run: |
        docker login docker.cnb.cool -u cnb -p ${{ secrets.cnb }}

    - name: Setup Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64,linux/arm64,linux/arm/v7

    - name: Process Images with Update Check
      run: |
        set -e  # å‡ºç°é”™è¯¯æ—¶é€€å‡º
        
        # è·å–å½“å‰æ—¶é—´æˆ³ç”¨äºä¸´æ—¶æ ‡ç­¾
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        
        while IFS= read -r line; do
          # è·³è¿‡æ³¨é‡Š/ç©ºè¡Œ
          [[ "$line" =~ ^#|^$ ]] && continue

          # è§£æè¾“å…¥
          src_image=$(echo "$line" | awk '{print $1}')
          dest_image=$(echo "$line" | awk '{print $2}')
          platforms=$(echo "$line" | awk '{print $3}' | tr ',' ' ')

          echo "ğŸ” Processing: $src_image => $dest_image (${platforms// /,})"

          # æ£€æŸ¥æºé•œåƒæ˜¯å¦æœ‰æ›´æ–°
          NEED_UPDATE=false
          LATEST_DIGEST=$(docker manifest inspect $src_image | jq -r '.config.digest')
          
          # å°è¯•è·å–ç›®æ ‡é•œåƒçš„å½“å‰digest
          if docker manifest inspect $dest_image &> /dev/null; then
            CURRENT_DIGEST=$(docker manifest inspect $dest_image | jq -r '.config.digest')
            if [ "$LATEST_DIGEST" != "$CURRENT_DIGEST" ]; then
              NEED_UPDATE=true
              echo "ğŸ”„ Update detected for $src_image"
            else
              echo "âœ… $dest_image is already up-to-date"
              continue
            fi
          else
            NEED_UPDATE=true
            echo "ğŸ†• $dest_image does not exist, will create"
          fi

          if [ "$NEED_UPDATE" = true ]; then
            # åˆ›å»ºmanifestå‘½ä»¤
            manifest_cmd="docker manifest create ${dest_image}"
            
            # å¤„ç†æ¯ä¸ªå¹³å°
            for platform in $platforms; do
              # æ‹‰å–æŒ‡å®šå¹³å°çš„é•œåƒ
              docker pull --platform=$platform $src_image
              
              # ä½¿ç”¨æ—¶é—´æˆ³åˆ›å»ºä¸´æ—¶æ ‡ç­¾
              temp_tag="${dest_image}-${TIMESTAMP}-$(echo $platform | sed 's/\//-/g')"
              docker tag $src_image $temp_tag
              docker push $temp_tag
              
              # æ·»åŠ åˆ°manifest
              manifest_cmd+=" --amend $temp_tag"
              
              # æ¸…ç†
              docker rmi $src_image $temp_tag || true
            done

            # åˆ›å»ºå¹¶æ¨é€manifest
            eval $manifest_cmd
            docker manifest push $dest_image

            # æ¸…ç†æ—§çš„ä¸´æ—¶é•œåƒ
            docker system prune -a -f

            echo "âœ… Successfully updated multi-arch: $dest_image"
          fi
        done < images.txt

    - name: Clean up
      run: |
        docker system prune -a -f